package com.architecture.memory.orkestify.service.github;

import com.architecture.memory.orkestify.dto.github.ImpactReport;
import com.architecture.memory.orkestify.dto.github.ImpactReport.AffectedEndpoint;
import com.architecture.memory.orkestify.dto.github.ImpactReport.AffectedFlow;
import com.architecture.memory.orkestify.dto.github.ImpactReport.ChangedComponent;
import com.architecture.memory.orkestify.dto.graph.CircularDependency;
import com.architecture.memory.orkestify.dto.graph.DiffSummary;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Formats an ImpactReport into a Markdown comment for GitHub PRs.
 */
@Component
public class ImpactReportFormatter {

    /**
     * Format the full impact report as a GitHub PR comment in Markdown.
     */
    public String format(ImpactReport report) {
        StringBuilder md = new StringBuilder();

        md.append("## \uD83C\uDFD7\uFE0F Architecture Impact Report\n\n");

        // Summary section
        appendSummary(md, report);

        // Changed components
        if (!report.getChangedComponents().isEmpty()) {
            appendChangedComponents(md, report.getChangedComponents());
        }

        // Affected endpoints
        if (!report.getAffectedEndpoints().isEmpty()) {
            appendAffectedEndpoints(md, report.getAffectedEndpoints());
        }

        // Affected flows
        if (!report.getAffectedFlows().isEmpty()) {
            appendAffectedFlows(md, report.getAffectedFlows());
        }

        // Circular dependencies
        if (!report.getNewCircularDependencies().isEmpty()) {
            appendCircularDependencies(md, report.getNewCircularDependencies());
        }

        // Diff summary
        if (report.getDiffSummary() != null) {
            appendDiffSummary(md, report.getDiffSummary());
        }

        // Warnings
        if (!report.getWarnings().isEmpty()) {
            appendWarnings(md, report.getWarnings());
        }

        md.append("\n---\n*Generated by Orkestify*\n");

        return md.toString();
    }

    /**
     * Format a brief error report when analysis fails.
     */
    public String formatError(String branchName, int prNumber, String error) {
        StringBuilder md = new StringBuilder();
        md.append("## \uD83C\uDFD7\uFE0F Architecture Impact Report\n\n");
        md.append("> **Analysis failed** for branch `").append(branchName).append("`\n\n");
        md.append("**Error:** ").append(error).append("\n\n");
        md.append("The shadow graph analysis could not be completed. ");
        md.append("This may be due to compilation issues in the branch or infrastructure problems.\n\n");
        md.append("---\n*Generated by Orkestify*\n");
        return md.toString();
    }

    /**
     * Format a "processing" comment posted immediately while analysis runs.
     */
    public String formatProcessing(String branchName, int prNumber) {
        StringBuilder md = new StringBuilder();
        md.append("## \uD83C\uDFD7\uFE0F Architecture Impact Report\n\n");
        md.append("> **Analyzing** branch `").append(branchName).append("` ...\n\n");
        md.append("Shadow graph analysis is in progress. This comment will be updated with results.\n\n");
        md.append("---\n*Generated by Orkestify*\n");
        return md.toString();
    }

    // ========================= SECTION FORMATTERS =========================

    private void appendSummary(StringBuilder md, ImpactReport report) {
        long architectureComponents = report.getChangedComponents().stream()
                .filter(c -> !"Other".equals(c.getType()))
                .count();
        long otherFiles = report.getChangedComponents().stream()
                .filter(c -> "Other".equals(c.getType()))
                .count();

        md.append("### Summary\n\n");
        md.append("| Metric | Count |\n");
        md.append("|--------|-------|\n");
        md.append("| Architecture components changed | ").append(architectureComponents).append(" |\n");
        md.append("| Endpoints affected | ").append(report.getAffectedEndpoints().size()).append(" |\n");
        md.append("| Request flows affected | ").append(report.getAffectedFlows().size()).append(" |\n");
        md.append("| New circular dependencies | ").append(report.getNewCircularDependencies().size()).append(" |\n");

        if (otherFiles > 0) {
            md.append("| Other files changed | ").append(otherFiles).append(" |\n");
        }

        md.append("\n");
    }

    private void appendChangedComponents(StringBuilder md, List<ChangedComponent> components) {
        md.append("### Changed Components\n\n");
        md.append("| Type | Class | Status | +/- |\n");
        md.append("|------|-------|--------|-----|\n");

        for (ChangedComponent c : components) {
            if ("Other".equals(c.getType())) continue;
            md.append("| ").append(typeIcon(c.getType())).append(" ").append(c.getType());
            md.append(" | `").append(c.getClassName()).append("`");
            md.append(" | ").append(statusBadge(c.getFileStatus()));
            md.append(" | +").append(c.getLinesAdded()).append(" -").append(c.getLinesRemoved());
            md.append(" |\n");
        }

        md.append("\n");

        // Detail: upstream/downstream for each changed component
        for (ChangedComponent c : components) {
            if ("Other".equals(c.getType())) continue;
            if (c.getUpstreamCallers().isEmpty() && c.getDownstreamCallees().isEmpty()) continue;

            md.append("<details>\n<summary><b>").append(c.getClassName()).append("</b> dependency details</summary>\n\n");

            if (!c.getUpstreamCallers().isEmpty()) {
                md.append("**Called by:** ");
                md.append(String.join(", ", c.getUpstreamCallers().stream().map(s -> "`" + s + "`").toList()));
                md.append("\n\n");
            }
            if (!c.getDownstreamCallees().isEmpty()) {
                md.append("**Calls:** ");
                md.append(String.join(", ", c.getDownstreamCallees().stream().map(s -> "`" + s + "`").toList()));
                md.append("\n\n");
            }

            md.append("</details>\n\n");
        }
    }

    private void appendAffectedEndpoints(StringBuilder md, List<AffectedEndpoint> endpoints) {
        md.append("### Affected Endpoints\n\n");
        md.append("| Method | Path | Reason |\n");
        md.append("|--------|------|--------|\n");

        for (AffectedEndpoint ep : endpoints) {
            md.append("| `").append(ep.getHttpMethod()).append("`");
            md.append(" | `").append(ep.getPath()).append("`");
            md.append(" | ").append(ep.getReason() != null ? ep.getReason() : "Affected");
            md.append(" |\n");
        }

        md.append("\n");
    }

    private void appendAffectedFlows(StringBuilder md, List<AffectedFlow> flows) {
        md.append("### Affected Request Flows\n\n");

        for (AffectedFlow flow : flows) {
            md.append("**").append(flow.getEndpoint()).append("**\n");
            md.append("```\n");

            List<String> chain = flow.getCallChain();
            for (int i = 0; i < chain.size(); i++) {
                String node = chain.get(i);
                boolean isAffected = node.equals(flow.getAffectedAt());
                md.append(isAffected ? " >> " : "    ");
                md.append(node);
                if (i < chain.size() - 1) {
                    md.append("\n    |\n");
                }
            }
            md.append("\n```\n\n");
        }
    }

    private void appendCircularDependencies(StringBuilder md, List<CircularDependency> deps) {
        md.append("### :warning: New Circular Dependencies\n\n");

        for (CircularDependency dep : deps) {
            String severity = dep.getSeverity() == CircularDependency.Severity.ERROR ? ":x:" : ":warning:";
            md.append(severity).append(" **").append(dep.getDescription()).append("**\n");
            md.append("```\n");
            md.append(String.join(" -> ", dep.getCycle()));
            md.append("\n```\n\n");
        }
    }

    private void appendDiffSummary(StringBuilder md, DiffSummary summary) {
        md.append("### Graph Diff Summary\n\n");
        md.append("| Change Type | Count |\n");
        md.append("|-------------|-------|\n");
        md.append("| Nodes added | ").append(summary.getNodesAdded()).append(" |\n");
        md.append("| Nodes modified | ").append(summary.getNodesModified()).append(" |\n");
        md.append("| Nodes removed | ").append(summary.getNodesRemoved()).append(" |\n");
        md.append("| Relationships added | ").append(summary.getRelationshipsAdded()).append(" |\n");
        md.append("| Relationships removed | ").append(summary.getRelationshipsRemoved()).append(" |\n");

        if (summary.getAddedByType() != null && !summary.getAddedByType().isEmpty()) {
            md.append("\n**Added by type:** ");
            md.append(formatTypeMap(summary.getAddedByType()));
            md.append("\n\n");
        }
        if (summary.getModifiedByType() != null && !summary.getModifiedByType().isEmpty()) {
            md.append("**Modified by type:** ");
            md.append(formatTypeMap(summary.getModifiedByType()));
            md.append("\n\n");
        }
        if (summary.getRemovedByType() != null && !summary.getRemovedByType().isEmpty()) {
            md.append("**Removed by type:** ");
            md.append(formatTypeMap(summary.getRemovedByType()));
            md.append("\n\n");
        }
    }

    private void appendWarnings(StringBuilder md, List<String> warnings) {
        md.append("### Notes\n\n");
        for (String warning : warnings) {
            md.append("- ").append(warning).append("\n");
        }
        md.append("\n");
    }

    // ========================= HELPERS =========================

    private String typeIcon(String type) {
        return switch (type) {
            case "Controller" -> "\uD83C\uDFAE";
            case "Service" -> "\u2699\uFE0F";
            case "Repository" -> "\uD83D\uDDC4\uFE0F";
            case "KafkaListener" -> "\uD83D\uDCE8";
            default -> "\uD83D\uDCC4";
        };
    }

    private String statusBadge(String status) {
        return switch (status) {
            case "added" -> "\uD83C\uDD95 added";
            case "removed" -> "\u274C removed";
            case "modified" -> "\u270F\uFE0F modified";
            case "renamed" -> "\u27A1\uFE0F renamed";
            default -> status;
        };
    }

    private String formatTypeMap(java.util.Map<String, Integer> map) {
        return map.entrySet().stream()
                .map(e -> e.getKey() + ": " + e.getValue())
                .reduce((a, b) -> a + ", " + b)
                .orElse("");
    }
}
