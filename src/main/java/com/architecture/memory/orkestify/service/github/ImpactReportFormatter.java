package com.architecture.memory.orkestify.service.github;

import com.architecture.memory.orkestify.dto.github.ImpactReport;
import com.architecture.memory.orkestify.dto.github.ImpactReport.AffectedEndpoint;
import com.architecture.memory.orkestify.dto.github.ImpactReport.AffectedFlow;
import com.architecture.memory.orkestify.dto.github.ImpactReport.ChangedComponent;
import com.architecture.memory.orkestify.dto.github.RiskAssessment;
import com.architecture.memory.orkestify.dto.github.RiskAssessment.RiskFactor;
import com.architecture.memory.orkestify.dto.github.RiskAssessment.RecommendedAction;
import com.architecture.memory.orkestify.dto.graph.CircularDependency;
import com.architecture.memory.orkestify.dto.graph.DiffSummary;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Formats an ImpactReport into a Markdown comment for GitHub PRs.
 */
@Component
public class ImpactReportFormatter {

    /**
     * Format the full impact report as a GitHub PR comment in Markdown.
     */
    public String format(ImpactReport report, RiskAssessment riskAssessment) {
        StringBuilder md = new StringBuilder();

        md.append("## \uD83C\uDFD7\uFE0F Architecture Impact Report\n\n");

        // Risk Assessment section (at the top)
        if (riskAssessment != null) {
            appendRiskAssessment(md, riskAssessment);
        }

        // Summary section
        appendSummary(md, report);

        // Changed components
        if (!report.getChangedComponents().isEmpty()) {
            appendChangedComponents(md, report.getChangedComponents());
        }

        // Affected endpoints
        if (!report.getAffectedEndpoints().isEmpty()) {
            appendAffectedEndpoints(md, report.getAffectedEndpoints());
        }

        // Affected flows
        if (!report.getAffectedFlows().isEmpty()) {
            appendAffectedFlows(md, report.getAffectedFlows());
        }

        // Circular dependencies
        if (!report.getNewCircularDependencies().isEmpty()) {
            appendCircularDependencies(md, report.getNewCircularDependencies());
        }

        // Diff summary
        if (report.getDiffSummary() != null) {
            appendDiffSummary(md, report.getDiffSummary());
        }

        // Warnings
        if (!report.getWarnings().isEmpty()) {
            appendWarnings(md, report.getWarnings());
        }

        md.append("\n---\n*Generated by Orkestify*\n");

        return md.toString();
    }

    /**
     * Format a brief error report when analysis fails.
     */
    public String formatError(String branchName, int prNumber, String error) {
        StringBuilder md = new StringBuilder();
        md.append("## \uD83C\uDFD7\uFE0F Architecture Impact Report\n\n");
        md.append("> **Analysis failed** for branch `").append(branchName).append("`\n\n");
        md.append("**Error:** ").append(error).append("\n\n");
        md.append("The shadow graph analysis could not be completed. ");
        md.append("This may be due to compilation issues in the branch or infrastructure problems.\n\n");
        md.append("---\n*Generated by Orkestify*\n");
        return md.toString();
    }

    /**
     * Format a "processing" comment posted immediately while analysis runs.
     */
    public String formatProcessing(String branchName, int prNumber) {
        StringBuilder md = new StringBuilder();
        md.append("## \uD83C\uDFD7\uFE0F Architecture Impact Report\n\n");
        md.append("> **Analyzing** branch `").append(branchName).append("` ...\n\n");
        md.append("Shadow graph analysis is in progress. This comment will be updated with results.\n\n");
        md.append("---\n*Generated by Orkestify*\n");
        return md.toString();
    }

    // ========================= SECTION FORMATTERS =========================

    private void appendRiskAssessment(StringBuilder md, RiskAssessment assessment) {
        md.append("## üéØ Risk Assessment\n\n");

        // Overall Risk header
        md.append("**Overall Risk: ").append(assessment.getOverallRiskLevel().getLabel()).append("** ");
        md.append(assessment.getOverallRiskLevel().getEmoji()).append("  \n");
        md.append("**Risk Score: ").append(assessment.getOverallScore()).append("/100**\n\n");

        // Score Breakdown
        md.append("### Score Breakdown\n");
        RiskAssessment.ScoreBreakdown breakdown = assessment.getScoreBreakdown();
        md.append("- üî¥ Breaking Changes: ").append(breakdown.getBreakingChanges()).append("/40");
        md.append(breakdown.getBreakingChanges() >= 20 ? " (High impact)" : "").append("\n");
        md.append("- üü° Downstream Impact: ").append(breakdown.getDownstreamImpact()).append("/30");
        md.append(breakdown.getDownstreamImpact() >= 15 ? " (Significant)" : "").append("\n");
        md.append("- üü¢ Service Criticality: ").append(breakdown.getServiceCriticality()).append("/20");
        md.append(breakdown.getServiceCriticality() >= 12 ? " (Critical services)" : "").append("\n");
        md.append("- üü¢ Change Complexity: ").append(breakdown.getChangeComplexity()).append("/10");
        md.append(breakdown.getChangeComplexity() >= 7 ? " (Complex)" : "").append("\n\n");

        md.append("---\n\n");

        // Key Risk Factors
        if (!assessment.getRiskFactors().isEmpty()) {
            md.append("### ‚ö†Ô∏è Key Risk Factors\n\n");

            // Group by severity
            List<RiskFactor> highSeverity = assessment.getRiskFactors().stream()
                    .filter(f -> f.getSeverity() == RiskFactor.Severity.HIGH)
                    .toList();
            List<RiskFactor> mediumSeverity = assessment.getRiskFactors().stream()
                    .filter(f -> f.getSeverity() == RiskFactor.Severity.MEDIUM)
                    .toList();
            List<RiskFactor> lowSeverity = assessment.getRiskFactors().stream()
                    .filter(f -> f.getSeverity() == RiskFactor.Severity.LOW)
                    .toList();

            if (!highSeverity.isEmpty()) {
                md.append("**HIGH SEVERITY**\n");
                for (RiskFactor factor : highSeverity) {
                    md.append("- ").append(factor.getDescription()).append("\n");
                }
                md.append("\n");
            }

            if (!mediumSeverity.isEmpty()) {
                md.append("**MEDIUM SEVERITY**\n");
                for (RiskFactor factor : mediumSeverity) {
                    md.append("- ").append(factor.getDescription()).append("\n");
                }
                md.append("\n");
            }

            if (!lowSeverity.isEmpty()) {
                md.append("**LOW SEVERITY**\n");
                for (RiskFactor factor : lowSeverity) {
                    md.append("- ").append(factor.getDescription()).append("\n");
                }
                md.append("\n");
            }

            md.append("---\n\n");
        }

        // Recommended Actions
        if (!assessment.getRecommendedActions().isEmpty()) {
            md.append("### ‚úÖ Recommended Actions\n\n");

            List<RecommendedAction> beforeMerging = assessment.getRecommendedActions().stream()
                    .filter(a -> a.getCategory() == RecommendedAction.Category.BEFORE_MERGING)
                    .toList();

            if (!beforeMerging.isEmpty()) {
                md.append("**Before Merging:**\n");
                for (RecommendedAction action : beforeMerging) {
                    md.append("- [ ] ").append(action.getDescription()).append("\n");
                }
                md.append("\n");
            }
        }

        // Deployment Strategy
        if (assessment.getDeploymentStrategy() != null) {
            RiskAssessment.DeploymentStrategy strategy = assessment.getDeploymentStrategy();
            md.append("**Deployment Strategy:**\n");
            md.append("- ").append(strategy.getRecommendation()).append("\n");
            if (strategy.isFeatureFlagRequired()) {
                md.append("- Feature flag: **Required**\n");
            } else {
                md.append("- Feature flag: Not required\n");
            }
            if (strategy.getReasoning() != null) {
                md.append("- Reasoning: ").append(strategy.getReasoning()).append("\n");
            }
            md.append("\n");
        }

        // Merge Status
        md.append("**Merge Status:** ").append(assessment.getMergeStatus()).append("\n");

        md.append("---\n\n");
    }

    private void appendSummary(StringBuilder md, ImpactReport report) {
        long architectureComponents = report.getChangedComponents().stream()
                .filter(c -> !"Other".equals(c.getType()))
                .count();
        long otherFiles = report.getChangedComponents().stream()
                .filter(c -> "Other".equals(c.getType()))
                .count();

        md.append("### Summary\n\n");
        md.append("| Metric | Count |\n");
        md.append("|--------|-------|\n");
        md.append("| Architecture components changed | ").append(architectureComponents).append(" |\n");
        md.append("| Endpoints affected | ").append(report.getAffectedEndpoints().size()).append(" |\n");
        md.append("| Request flows affected | ").append(report.getAffectedFlows().size()).append(" |\n");
        md.append("| New circular dependencies | ").append(report.getNewCircularDependencies().size()).append(" |\n");

        if (otherFiles > 0) {
            md.append("| Other files changed | ").append(otherFiles).append(" |\n");
        }

        md.append("\n");
    }

    private void appendChangedComponents(StringBuilder md, List<ChangedComponent> components) {
        md.append("### Changed Components\n\n");
        md.append("| Type | Class | Status | +/- |\n");
        md.append("|------|-------|--------|-----|\n");

        for (ChangedComponent c : components) {
            if ("Other".equals(c.getType())) continue;
            md.append("| ").append(typeIcon(c.getType())).append(" ").append(c.getType());
            md.append(" | `").append(c.getClassName()).append("`");
            md.append(" | ").append(statusBadge(c.getFileStatus()));
            md.append(" | +").append(c.getLinesAdded()).append(" -").append(c.getLinesRemoved());
            md.append(" |\n");
        }

        md.append("\n");

        // Detail: upstream/downstream for each changed component
        for (ChangedComponent c : components) {
            if ("Other".equals(c.getType())) continue;
            if (c.getUpstreamCallers().isEmpty() && c.getDownstreamCallees().isEmpty()) continue;

            md.append("<details>\n<summary><b>").append(c.getClassName()).append("</b> dependency details</summary>\n\n");

            if (!c.getUpstreamCallers().isEmpty()) {
                md.append("**Called by:** ");
                md.append(String.join(", ", c.getUpstreamCallers().stream().map(s -> "`" + s + "`").toList()));
                md.append("\n\n");
            }
            if (!c.getDownstreamCallees().isEmpty()) {
                md.append("**Calls:** ");
                md.append(String.join(", ", c.getDownstreamCallees().stream().map(s -> "`" + s + "`").toList()));
                md.append("\n\n");
            }

            md.append("</details>\n\n");
        }
    }

    private void appendAffectedEndpoints(StringBuilder md, List<AffectedEndpoint> endpoints) {
        md.append("### Affected Endpoints\n\n");
        md.append("| Method | Path | Reason |\n");
        md.append("|--------|------|--------|\n");

        for (AffectedEndpoint ep : endpoints) {
            md.append("| `").append(ep.getHttpMethod()).append("`");
            md.append(" | `").append(ep.getPath()).append("`");
            md.append(" | ").append(ep.getReason() != null ? ep.getReason() : "Affected");
            md.append(" |\n");
        }

        md.append("\n");
    }

    private void appendAffectedFlows(StringBuilder md, List<AffectedFlow> flows) {
        md.append("### Affected Request Flows\n\n");

        for (AffectedFlow flow : flows) {
            md.append("**").append(flow.getEndpoint()).append("**\n");
            md.append("```\n");

            List<String> chain = flow.getCallChain();
            for (int i = 0; i < chain.size(); i++) {
                String node = chain.get(i);
                boolean isAffected = node.equals(flow.getAffectedAt());
                md.append(isAffected ? " >> " : "    ");
                md.append(node);
                if (i < chain.size() - 1) {
                    md.append("\n    |\n");
                }
            }
            md.append("\n```\n\n");
        }
    }

    private void appendCircularDependencies(StringBuilder md, List<CircularDependency> deps) {
        md.append("### :warning: New Circular Dependencies\n\n");

        for (CircularDependency dep : deps) {
            String severity = dep.getSeverity() == CircularDependency.Severity.ERROR ? ":x:" : ":warning:";
            md.append(severity).append(" **").append(dep.getDescription()).append("**\n");
            md.append("```\n");
            md.append(String.join(" -> ", dep.getCycle()));
            md.append("\n```\n\n");
        }
    }

    private void appendDiffSummary(StringBuilder md, DiffSummary summary) {
        md.append("### Graph Diff Summary\n\n");
        md.append("| Change Type | Count |\n");
        md.append("|-------------|-------|\n");
        md.append("| Nodes added | ").append(summary.getNodesAdded()).append(" |\n");
        md.append("| Nodes modified | ").append(summary.getNodesModified()).append(" |\n");
        md.append("| Nodes removed | ").append(summary.getNodesRemoved()).append(" |\n");
        md.append("| Relationships added | ").append(summary.getRelationshipsAdded()).append(" |\n");
        md.append("| Relationships removed | ").append(summary.getRelationshipsRemoved()).append(" |\n");

        if (summary.getAddedByType() != null && !summary.getAddedByType().isEmpty()) {
            md.append("\n**Added by type:** ");
            md.append(formatTypeMap(summary.getAddedByType()));
            md.append("\n\n");
        }
        if (summary.getModifiedByType() != null && !summary.getModifiedByType().isEmpty()) {
            md.append("**Modified by type:** ");
            md.append(formatTypeMap(summary.getModifiedByType()));
            md.append("\n\n");
        }
        if (summary.getRemovedByType() != null && !summary.getRemovedByType().isEmpty()) {
            md.append("**Removed by type:** ");
            md.append(formatTypeMap(summary.getRemovedByType()));
            md.append("\n\n");
        }
    }

    private void appendWarnings(StringBuilder md, List<String> warnings) {
        md.append("### Notes\n\n");
        for (String warning : warnings) {
            md.append("- ").append(warning).append("\n");
        }
        md.append("\n");
    }

    // ========================= HELPERS =========================

    private String typeIcon(String type) {
        return switch (type) {
            case "Controller" -> "\uD83C\uDFAE";
            case "Service" -> "\u2699\uFE0F";
            case "Repository" -> "\uD83D\uDDC4\uFE0F";
            case "KafkaListener" -> "\uD83D\uDCE8";
            default -> "\uD83D\uDCC4";
        };
    }

    private String statusBadge(String status) {
        return switch (status) {
            case "added" -> "\uD83C\uDD95 added";
            case "removed" -> "\u274C removed";
            case "modified" -> "\u270F\uFE0F modified";
            case "renamed" -> "\u27A1\uFE0F renamed";
            default -> status;
        };
    }

    private String formatTypeMap(java.util.Map<String, Integer> map) {
        return map.entrySet().stream()
                .map(e -> e.getKey() + ": " + e.getValue())
                .reduce((a, b) -> a + ", " + b)
                .orElse("");
    }
}
